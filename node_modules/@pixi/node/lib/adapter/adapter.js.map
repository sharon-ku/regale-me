{"version":3,"file":"adapter.js","sources":["../../src/adapter/adapter.ts"],"sourcesContent":["import { fetch, Request, Response } from 'cross-fetch';\nimport fs from 'fs';\nimport createContext from 'gl';\nimport { settings, utils } from '@pixi/core';\nimport { NodeCanvasElement } from './NodeCanvasElement';\n\nimport type { IAdapter, ICanvas } from '@pixi/core';\n\nexport const NodeAdapter = {\n    /**\n     * Creates a canvas element of the given size.\n     * This canvas is created using the node-canvas package and uses the gl package to create a webgl context.\n     * @param width - width of the canvas\n     * @param height - height of the canvas\n     */\n    createCanvas: (width?: number, height?: number) => new NodeCanvasElement(width, height) as unknown as ICanvas,\n    /** Returns a webgl rendering context using the gl package. */\n    getWebGLRenderingContext: () => createContext(1, 1) as unknown as typeof WebGLRenderingContext,\n    /** Returns the fake user agent string of `node` */\n    getNavigator: () => ({ userAgent: 'node' }),\n    /** Returns the path from which the process is being run */\n    getBaseUrl: () => process.cwd(),\n    getFontFaceSet: () => null,\n    fetch: (url: RequestInfo, options?: RequestInit) =>\n    {\n        const request = new Request(url, options);\n\n        // check if urls starts with http(s) as only these are supported by node-fetch\n        if (utils.path.isUrl(request.url))\n        {\n            return fetch(url, request);\n        }\n\n        return new Promise((resolve, reject) =>\n        {\n            const filePath = utils.path.normalize(request.url);\n\n            if (!fs.existsSync(filePath))\n            {\n                reject(`File not found: ${filePath}`);\n            }\n            const readStream = fs.createReadStream(filePath);\n\n            // eslint-disable-next-line func-names\n            readStream.on('open', function ()\n            {\n                resolve(new Response(readStream as unknown as ReadableStream, {\n                    url: request.url,\n                    status: 200,\n                    statusText: 'OK',\n                    size: fs.statSync(filePath).size,\n                    timeout: (request as any).timeout\n                } as unknown as ResponseInit));\n            });\n        });\n    },\n} as IAdapter;\n\nsettings.ADAPTER = NodeAdapter;\n\nexport { settings };\n"],"names":["NodeCanvasElement","createContext","Request","utils","fetch","fs","Response","settings"],"mappings":";;;;;;;;;;;;;;;AAQO,MAAM,WAAc,GAAA;AAAA,EAOvB,cAAc,CAAC,KAAA,EAAgB,WAAoB,IAAIA,mCAAA,CAAkB,OAAO,MAAM,CAAA;AAAA,EAEtF,wBAA0B,EAAA,MAAMC,mCAAc,CAAA,CAAA,EAAG,CAAC,CAAA;AAAA,EAElD,YAAc,EAAA,OAAS,EAAA,SAAA,EAAW,MAAO,EAAA,CAAA;AAAA,EAEzC,UAAA,EAAY,MAAM,OAAA,CAAQ,GAAI,EAAA;AAAA,EAC9B,gBAAgB,MAAM,IAAA;AAAA,EACtB,KAAA,EAAO,CAAC,GAAA,EAAkB,OAC1B,KAAA;AACI,IAAA,MAAM,OAAU,GAAA,IAAIC,kBAAQ,CAAA,GAAA,EAAK,OAAO,CAAA,CAAA;AAGxC,IAAA,IAAIC,UAAM,CAAA,IAAA,CAAK,KAAM,CAAA,OAAA,CAAQ,GAAG,CAChC,EAAA;AACI,MAAO,OAAAC,gBAAA,CAAM,KAAK,OAAO,CAAA,CAAA;AAAA,KAC7B;AAEA,IAAA,OAAO,IAAI,OAAA,CAAQ,CAAC,OAAA,EAAS,MAC7B,KAAA;AACI,MAAA,MAAM,QAAW,GAAAD,UAAA,CAAM,IAAK,CAAA,SAAA,CAAU,QAAQ,GAAG,CAAA,CAAA;AAEjD,MAAA,IAAI,CAACE,sBAAA,CAAG,UAAW,CAAA,QAAQ,CAC3B,EAAA;AACI,QAAA,MAAA,CAAO,mBAAmB,QAAU,CAAA,CAAA,CAAA,CAAA;AAAA,OACxC;AACA,MAAM,MAAA,UAAA,GAAaA,sBAAG,CAAA,gBAAA,CAAiB,QAAQ,CAAA,CAAA;AAG/C,MAAW,UAAA,CAAA,EAAA,CAAG,QAAQ,WACtB;AACI,QAAQ,OAAA,CAAA,IAAIC,oBAAS,UAAyC,EAAA;AAAA,UAC1D,KAAK,OAAQ,CAAA,GAAA;AAAA,UACb,MAAQ,EAAA,GAAA;AAAA,UACR,UAAY,EAAA,IAAA;AAAA,UACZ,IAAM,EAAAD,sBAAA,CAAG,QAAS,CAAA,QAAQ,CAAE,CAAA,IAAA;AAAA,UAC5B,SAAU,OAAgB,CAAA,OAAA;AAAA,SACF,CAAC,CAAA,CAAA;AAAA,OAChC,CAAA,CAAA;AAAA,KACJ,CAAA,CAAA;AAAA,GACL;AACJ,EAAA;AAEAE,aAAA,CAAS,OAAU,GAAA,WAAA;;;;;;;;"}